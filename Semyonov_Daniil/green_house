#include <DHT.h>
#include <Adafruit_Sensor.h>

#define PUMP_PIN 5           // pump control pin
#define LIGHT_PIN 6          // light control pin
#define HEAT_PIN 4           // heater control pin
#define VENT_PIN 7           // fan control pin
#define DHT_PIN 12           // DHT temperature and humidity sensor pin
#define DEFAULT_LIGHT_SENSOR_PIN A0  // default analog light sensor pin
#define DEFAULT_SOIL_SENSOR_PIN A3   // default analog soil moisture sensor pin

// Pins for 4 temperature sensors 
#define TEMP_SENSOR_1 A1
#define TEMP_SENSOR_2 A2
#define TEMP_SENSOR_3 A4
#define TEMP_SENSOR_4 A5

// maximum number of sensors
const int MAX_LIGHT_SENSORS = 4;     // maximum 4 light sensors
const int MAX_SOIL_SENSORS = 4;      // maximum 4 soil sensors
const int MAX_TEMP_SENSORS = 4;      // maximum 4 temperature sensors

// range structure for sensor thresholds
struct Range {
  int minVal;  // lower range boundary
  int maxVal;  // upper range boundary
};

// air sensor structure
struct AirSensor {
  int pin;          // sensor pin
  int temperature;  // last temperature reading
  int humidity;     // last humidity reading 
  bool is_normal;   // sensor data validity flag
  
  void get_data() {
    int h = dht.readHumidity();
    int t = dht.readTemperature();
    is_normal = !isnan(h) && !isnan(t);
    if (is_normal) {
      humidity = h;
      temperature = t;
    }
  }
};

// light sensors structure
struct LightSensors {
  int pins[MAX_LIGHT_SENSORS];   // array of sensor pins
  int values[MAX_LIGHT_SENSORS]; // array of sensor values
  int count;                     // number of active sensors
  Range limits;                  // light intensity thresholds
  bool shouldBeOn;               // flag indicating if light should be on
  
  void get_data() {
    for (int i = 0; i < count; i++)
      values[i] = analogRead(pins[i]);
  }
};

// soil sensors structure
struct SoilSensors {
  int pins[MAX_SOIL_SENSORS];    // array of sensor pins
  int values[MAX_SOIL_SENSORS];  // array of sensor values
  int count;                     // number of active sensors
  Range limits;                  // soil moisture thresholds
  bool pumpNeeded;               // flag indicating if watering is needed
  unsigned long lastPumpStart;   // start time of last watering
  unsigned long lastPumpEnd;     // end time of last watering
  unsigned long pumpMaxDuration; // maximum watering duration (ms)
  unsigned long pumpInterval;    // interval between waterings (ms)
  
  void get_data() {
    for (int i = 0; i < count; i++)
      values[i] = analogRead(pins[i]);
  }
};

// individual temperature sensor structure
struct Thermometer {
  int pin;
  int raw_value;
  float temperature;
  bool is_valid;
  
  void get_data() {
    raw_value = analogRead(pin);
    temperature = analogToTemperature(raw_value);
    is_valid = true;
  }
  
private:
  float analogToTemperature(int analogValue) {
    float voltage = analogValue * (5.0 / 1023.0);
    float temperature = (voltage - 0.5) * 100.0;
    return temperature;
  }
};

// temperature sensors collection structure
struct TempSensors {
  Thermometer sensors[MAX_TEMP_SENSORS];
  int count;
  float currentTemp;
  
  void get_data() {
    // Read all available sensors
    for (int i = 0; i < count; i++) {
      sensors[i].get_data();
    }
    // Default to average of all sensors
    currentTemp = get_average();
  }
  
  void get_data_merge(Thermometer& t1, Thermometer& t2) {
    t1.get_data();
    t2.get_data();
    currentTemp = (t1.temperature + t2.temperature) / 2.0;
  }
   
  void get_data_merge(Thermometer& t1, Thermometer& t2, Thermometer& t3) {
    t1.get_data();
    t2.get_data();
    t3.get_data();
    currentTemp = (t1.temperature + t2.temperature + t3.temperature) / 3.0;
  }
  
  void get_data_merge(Thermometer& t1, Thermometer& t2, Thermometer& t3, Thermometer& t4) {
    t1.get_data();
    t2.get_data();
    t3.get_data();
    t4.get_data();
    currentTemp = (t1.temperature + t2.temperature + t3.temperature + t4.temperature) / 4.0;
  }
  
  void get_data_merge(Thermometer& t1) {
    t1.get_data();
    currentTemp = t1.temperature;
  }
  
  // Get average of all available sensors
  float get_average() {
    float sum = 0;
    int valid_count = 0;
    for (int i = 0; i < count; i++) {
      sum += sensors[i].temperature;
      valid_count++;
    }
    return valid_count > 0 ? sum / valid_count : 0.0;
  }
};

// device control structures with power methods
struct Pump {
  int pin;
  bool is_on;
  
  void power() {
    digitalWrite(pin, is_on);
  }
};

struct LightCtrl {
  int pin;
  bool is_on;
  Range limits;
  
  void power() {
    digitalWrite(pin, !is_on);
  }
};

struct Heater {
  int pin;
  bool is_on;
  Range limits;
  
  void power() {
    digitalWrite(pin, is_on);
  }
};

struct Ventilation {
  int pin;
  bool is_on;
  Range humidityLimits;
  unsigned long lastVentTime;
  unsigned long ventInterval;
  unsigned long ventDuration;
  bool timerActive;
  
  void power() {
    digitalWrite(pin, is_on);
  }
};

// global objects
DHT dht(DHT_PIN, DHT11);

AirSensor air_sensor = {DHT_PIN, 0, 0, false};
LightSensors light_sensors;
SoilSensors soil_sensors;
TempSensors temp_sensors;
Pump pump = {PUMP_PIN, false};
LightCtrl lamp = {LIGHT_PIN, false, {0, 0}};
Heater heater = {HEAT_PIN, false, {0, 0}};
Ventilation vent = {VENT_PIN, false, {30, 75}, 0, 3600000UL, 60000UL, false};

// Individual thermometer objects
Thermometer thermometer1 = {TEMP_SENSOR_1, 0, 0.0, false};
Thermometer thermometer2 = {TEMP_SENSOR_2, 0, 0.0, false};
Thermometer thermometer3 = {TEMP_SENSOR_3, 0, 0.0, false};
Thermometer thermometer4 = {TEMP_SENSOR_4, 0, 0.0, false};

// time parameters
unsigned long currentMillis = 0;
unsigned long cycleStart = 0;
const unsigned long dayDuration = 10000UL;
const unsigned long nightDuration = 10000UL;
bool isNight = false;

unsigned long lastSerial = 0;
const unsigned long serialInterval = 5000UL;

// system parameters initialization function
void initParams() {
  // initialize light sensors
  light_sensors.count = 1;
  light_sensors.pins[0] = DEFAULT_LIGHT_SENSOR_PIN;
  light_sensors.limits = {300, 800};
  light_sensors.shouldBeOn = false;

  // initialize soil sensors
  soil_sensors.count = 1;
  soil_sensors.pins[0] = DEFAULT_SOIL_SENSOR_PIN;
  soil_sensors.limits = {500, 600};
  soil_sensors.pumpNeeded = false;
  soil_sensors.pumpMaxDuration = 10000UL;
  soil_sensors.pumpInterval = 10000UL;
  soil_sensors.lastPumpEnd = 0;

  // initialize temperature sensors collection
  temp_sensors.count = 4;
  temp_sensors.sensors[0] = thermometer1;
  temp_sensors.sensors[1] = thermometer2;
  temp_sensors.sensors[2] = thermometer3;
  temp_sensors.sensors[3] = thermometer4;
  temp_sensors.currentTemp = 0.0;

  // initialize devices
  lamp.limits = light_sensors.limits;
  heater.limits = {20, 27};
  vent.lastVentTime = currentMillis;

  // initialize day-night cycle
  cycleStart = currentMillis;
}

// control functions
void updateDayNight() {
  unsigned long elapsed = currentMillis - cycleStart;
  if (elapsed < dayDuration) {
    isNight = false;
  } else if (elapsed < dayDuration + nightDuration) {
    isNight = true;
  } else {
    cycleStart = currentMillis;
    isNight = false;
  }
}

void control_light() {
  int lightValue = light_sensors.values[0];
  bool lowLight = lightValue < light_sensors.limits.minVal;
  light_sensors.shouldBeOn = isNight || (!isNight && lowLight);
  lamp.is_on = light_sensors.shouldBeOn;
}

void control_air_humidity() {
  bool highHumidity = air_sensor.is_normal && air_sensor.humidity > vent.humidityLimits.maxVal;
  vent.is_on = vent.timerActive || highHumidity || heater.is_on || pump.is_on;
}

void ventilation_by_time() {
  if (!vent.timerActive && (currentMillis - vent.lastVentTime >= vent.ventInterval)) {
    vent.timerActive = true;
    vent.lastVentTime = currentMillis;
  }

  if (vent.timerActive && (currentMillis - vent.lastVentTime >= vent.ventDuration)) {
    vent.timerActive = false;
    vent.lastVentTime = currentMillis;
  }
}

void control_temperature(TempSensors& thermometer, Ventilation& fan, Heater& heater_dev) {
  if (air_sensor.is_normal) {
    heater_dev.is_on = thermometer.currentTemp < heater_dev.limits.minVal;
  } else {
    heater_dev.is_on = thermometer.currentTemp < heater_dev.limits.minVal;
  }
  
  control_air_humidity();
}

void control_dirt_humidity() {
  if (soil_sensors.count == 0) return;
  
  int soilValue = soil_sensors.values[0];
  bool soilIsDry = soilValue > soil_sensors.limits.minVal;
  bool enoughTimePassed = (currentMillis - soil_sensors.lastPumpEnd) >= soil_sensors.pumpInterval;
  
  soil_sensors.pumpNeeded = soilIsDry && enoughTimePassed;
  
  if (pump.is_on && (currentMillis - soil_sensors.lastPumpStart > soil_sensors.pumpMaxDuration)) {
    pump.is_on = false;
    soil_sensors.pumpNeeded = false;
    soil_sensors.lastPumpEnd = currentMillis;
    Serial.println("PUMP: Auto-stop after 10 seconds");
  }
}

void control_pump() {
  if (soil_sensors.pumpNeeded && !pump.is_on) {
    pump.is_on = true;
    soil_sensors.lastPumpStart = currentMillis;
    Serial.println("PUMP: Starting 10-second watering cycle");
  } else if (!soil_sensors.pumpNeeded && pump.is_on) {
    pump.is_on = false;
    soil_sensors.lastPumpEnd = currentMillis;
    Serial.println("PUMP: Stopping watering");
  }
}

void serial_log() {
  if (currentMillis - lastSerial < serialInterval) return;
  lastSerial = currentMillis;

  Serial.println("=== GREENHOUSE STATUS ===");
  Serial.print("Time: ");
  Serial.print(isNight ? "NIGHT" : "DAY");
  Serial.print(" | DHT:"); 
  Serial.print(air_sensor.is_normal ? "OK " : "FAIL ");
  if (air_sensor.is_normal) {
    Serial.print(air_sensor.temperature); 
    Serial.print("C "); 
    Serial.print(air_sensor.humidity); 
    Serial.print("%");
  }
  Serial.println();
  
  // Display individual thermometer readings
  Serial.print("Thermometers: ");
  Serial.print("T1:");
  Serial.print(thermometer1.temperature, 1);
  Serial.print("C T2:");
  Serial.print(thermometer2.temperature, 1);
  Serial.print("C T3:");
  Serial.print(thermometer3.temperature, 1);
  Serial.print("C T4:");
  Serial.print(thermometer4.temperature, 1);
  Serial.print("C | Final:");
  Serial.print(temp_sensors.currentTemp, 1);
  Serial.println("C");
  
  Serial.print("Light: "); 
  Serial.print(light_sensors.values[0]);
  Serial.print(" | Lamp: "); 
  Serial.println(lamp.is_on ? "ON" : "OFF");
  
  Serial.print("Soil: "); 
  Serial.print(soil_sensors.values[0]);
  Serial.print(" | Pump: "); 
  Serial.println(pump.is_on ? "ON" : "OFF");
  
  Serial.print("Heater: "); 
  Serial.print(heater.is_on ? "ON" : "OFF");
  Serial.print(" | Ventilation: "); 
  Serial.println(vent.is_on ? "ON" : "OFF");
  
  Serial.println("=========================");
}

void setup() {
  Serial.begin(9600);          
  dht.begin();
  
  pinMode(PUMP_PIN, OUTPUT);
  pinMode(LIGHT_PIN, OUTPUT);
  pinMode(HEAT_PIN, OUTPUT);
  pinMode(VENT_PIN, OUTPUT);

  initParams();
  
  digitalWrite(PUMP_PIN, LOW);
  digitalWrite(LIGHT_PIN, LOW);
  digitalWrite(HEAT_PIN, LOW);
  digitalWrite(VENT_PIN, LOW);
  
  Serial.println("System started - READY");
  Serial.println("Temperature sensors: 1=A1, 2=A2, 3=A4, 4=A5");
}

void loop() {
  currentMillis = millis();
  
  // Read all sensors
  air_sensor.get_data();
  light_sensors.get_data();
  soil_sensors.get_data();
  //Enter necessary thermometers
  temp_sensors.get_data_merge(thermometer1, thermometer2, thermometer3); 
 
  
  // Update system states
  updateDayNight();
  
  // Control systems
  control_light();
  control_air_humidity();
  ventilation_by_time();
  control_temperature(temp_sensors, vent, heater);
  control_dirt_humidity();
  control_pump();
  
  // Power all devices
  pump.power();
  lamp.power();
  heater.power();
  vent.power();
  
  // Logging
  serial_log();
  
  delay(100);
}
