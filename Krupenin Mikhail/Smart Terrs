#include "U8g2lib.h"
#include <math.h>

#include <Wire.h>

#define SHT20_ADDR1 0x40  //Temperature + humidity sensor I2C adress

//------------------------------------------------------------Bitmaps------------------------------------------------------------//

bool back_arrow_bitmap[36] = {0, };   //
bool warn_bitmap[36] = {0, };         // Empty bitmaps for bitmap inversion
bool error_bitmap[529] = {0, };       //

bool isErrFlashDisplayed = false;     // Flag to keep the error flash state in memory
unsigned long int errTimer = 0;       // Timer for millis()

bool colon_bitmap[] = { 1, 0, 0, 0, 1 };    // This is a boolean bitmap. 1 for color, 0 for no color. 
// The colon bitmap replaces the ":" symbol on the LCD, because the bitmap is more aestheticlly pleasing

bool back_arrow_bitmap_og[] = {
  0, 0, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0,
  1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1,
  0, 1, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0,
};
// OG (original) is used as READ-ONLY for inverting. To invert a bitmap you can write it to a blank one inverting each pixel

bool front_arrow_bitmap[] = {
  0, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 1, 0,
  1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1,
  0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 0, 0,
};

bool warn_bitmap_og[] = {
  0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0,
  0, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0,
};

bool heat_bitmap[] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

bool day_night_bitmap[] = {
  0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
  1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

bool error_bitmap_og[] = {
  0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1,
  1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1,
  1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1,
  1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1,
  1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1,
  1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1,
  1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1,
  1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1,
  1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1,
  0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0
};

bool error_highl_bitmap_og[] = {
  0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0,
  1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1,
  1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1,
  1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1,
  1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1,
  1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1,
  1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1,
  1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1,
  1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1,
  1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1,
  0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0
};

bool humidity_bitmap[] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0
};

bool left_arrow_bitmap[] = {
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0,
  0, 0, 1, 1, 1, 0,
  0, 0, 1, 1, 1, 0,
  0, 0, 1, 1, 1, 0,
  0, 1, 1, 1, 1, 0,
  0, 1, 1, 1, 1, 0,
  0, 1, 1, 1, 1, 0,
  0, 1, 1, 1, 1, 0,
  0, 0, 1, 1, 1, 0,
  0, 0, 1, 1, 1, 0,
  0, 0, 1, 1, 1, 0,
  0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0
};

bool left_arrow_empty_bitmap[] = {
  0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0,
  0, 0, 1, 0, 1, 0,
  0, 0, 1, 0, 1, 0,
  0, 0, 1, 0, 1, 0,
  0, 1, 0, 0, 1, 0,
  0, 1, 0, 0, 1, 0,
  0, 1, 0, 0, 1, 0,
  0, 1, 0, 0, 1, 0,
  0, 0, 1, 0, 1, 0,
  0, 0, 1, 0, 1, 0,
  0, 0, 1, 0, 1, 0,
  0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 1, 0,
  0, 0, 0, 0, 0, 0
};

bool right_arrow_bitmap[] = {
  0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 1, 1, 1, 1, 0,
  0, 1, 1, 1, 1, 0,
  0, 1, 1, 1, 1, 0,
  0, 1, 1, 1, 1, 0,
  0, 1, 1, 1, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 1, 1, 1, 0, 0,
  0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0
};

bool right_arrow_empty_bitmap[] = {
  0, 0, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 1, 0, 0, 1, 0,
  0, 1, 0, 0, 1, 0,
  0, 1, 0, 0, 1, 0,
  0, 1, 0, 0, 1, 0,
  0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 1, 0, 1, 0, 0,
  0, 1, 1, 0, 0, 0,
  0, 1, 1, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0
};

bool light_bitmap[] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

bool light_big_bitmap[] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

bool temp_humid_bitmap[] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0,
  0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0,
  0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0,
  0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,
  0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,
  0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0,
  0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

bool temperature_bitmap[] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

bool winter_bitmap[] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

bool sunrise_bitmap[] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0,
  0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

bool isInverted = false;  // Flag to keep the bitmap state in memory

//--------------------------------------------------------Input-Variables--------------------------------------------------------//

int rs = 7;   //
int rw = 6;   // LCD connection pins. For more info see ST7920 128x64 LCD datasheet
int e = 5;    //
int rst = 4;  //

U8G2_ST7920_128X64_1_SW_SPI u8g2(U8G2_R0, /* e=*/e, /* rw=*/rw, /* rs=*/rs, rst);   // Initialises the LCD

const int scrH = 64;   // Screen resolution (Height, Width)
const int scrW = 128;  //

#define encoderButton 16  // The button pin of the rotary encoder
int debounceTime = 200;   // Time when the program doesn't read the button, to prevent multiple readings of one click
unsigned long int currButtonTime = 0;   //Timer for millis()

#define SDA_PIN 1   // Custom I2C pins because the project is for ESP32
#define SCL_PIN 2   //

uint8_t multiplexerAddr = 0x70;   // I2C Adress of the multiplexer

const byte encoderPinA = 18;      // CLK pin of the rotary encoder
const byte encoderPinB = 17;      // DT pin of the rotary encoder
volatile int count = 0;       // 
int protectedCount = 0;       // Variables for rotary encoder direction detection 
int previousCount = 0;        //

#define readA digitalRead(18)   // Simplification
#define readB digitalRead(17)   //

int cursorX = 0;  //
int cursorY = 0;  // Cursor global coordinates
int cursorW = 0;  //
int cursorH = 0;  //

int selectedItem = 1;     // For figuring out what you're actually pressing
int selectedWindow = 1;   // For figuring out whhich window is currently open. See possible values below:
/*
Main Menu = 1
Temperature & Humidity = 2
Light & Heat = 3
Error Menu = 4
Daylight Cycle = 5
Sunrise & Sunset = 6
Winter Prep = 7
Error Fix = 8
Set Time = 9
Set Time in Winter Prep = 10
*/ 

short int prevWindow = 1;         // Records the previous window to correctly return you later
bool selectedLeftArrow = false;       // Flags for selecting arrows (to change their bitmaps)
bool selectedRightArrow = false;      //

#include <ACS712.h>

struct Terr {  // This program supporst up to 3 unique terrariums. Each terrarium has it's own nested data. This is it
  uint8_t tempHumAddr1; // I2C Multiplexer adresses of the temp+humid sensors
  uint8_t tempHumAddr2; //

  int temp1Storage[48] = {0, };  // An array of temperature logs from sensor 1 for the past 24h
  int temp2Storage[48] = {0,  }; // Same for temp sensor 2
  int hum1Storage[48] = {0,  };  // Same for humidity
  int hum2Storage[48] = {0,  };  //

  int temp1 = 0;     // Current temperture value on sensor 1
  int temp2 = 0;     // Same as for temperature sensor 1
  int tempMax = 1;   // The maximum temperature (either sensor) for the past 24h
  int tempMin = 50;  // The minimum temperature (either sensor) for the past 24h

  int hum1 = 0;      // 
  int hum2 = 0;      // Same only for humidity
  int humMax = 1;    //
  int humMin = 100;  //
  // The max and min values are set out of the normal range to catch all the data inbetween

  struct Light { // Nested struct for lamp data
    int lightPin; // LED relay pin
    int heatPin;  // Heat lamp relay pin
    //int UD;      
    //int INC;  WIP: Dimmers for sunrise and sunset. Currently hardcoded for test dimmer untill good ones arrive 
    //int CS;
    bool isLight = false;     //
    bool isLightOff = true;   // Bool logic for loggling light and heat. Explanation in Toggle function
    bool isHeat = false;      //
    bool isHeatOff = true;    //
  };
  short int sunriseHours[4] = {0, };      //
  short int sunriseMinutes[4] = {0, };    // Arrays for storing set times. HR : MIN would be HR[i] : MIN[i] 
  short int daylightHours[4] = {0, };     //
  short int daylightMinutes[4] = {0, };   //
  short int dayNumSelected = 1;       // Index of the winter array element to be set
  short int winterDays[20] = {0, };   // Array for storing winter prep hours per day
  bool winterIsActive = false;    // Flag to know if winter prep mode is active
  Light light;  // Nested struct initialiser
};

char sunriseStr[3] = {0, };                               // Char for int to char conversion to print data on the LCD
short int sunriseShifts[8] = { 0, 0, 64 - 8, 64 - 8, 0, 18, 0, 18 };  // A set of coordinate shifts to print out data
                                                                      // on a screen all at once
char daylightStr[3] = {0, };
short int daylightShifts[8] = { 0, 0, 49 - 8, 49 - 8, 0, 18, 0, 18 };

char dayNumStr[3] = {0, };
char winterDayVal[3] = {0, };

char errMessages[64][21] = {0, };   // An array of stored error messages
short int errCodes[12] = {0, };     // An array of possible error codes. See possible values below:
/*
0 = RTC not found
1-6 = Temp+HUM 1-6 not found
7-9 = Terr 1-3 lamp fail
*/
short int errCodePositions[64] = {0, };   // An array to correlate error codes to error messages
short int errDates[64][3] = {0, };        // An array to correlate error dates to error messages
int currentErrIndex = 0;                  // For figuring out which error message to display
char errMsg[21] = {0, };                  // Char to temporarily store new error message

bool isHours = true;    // Flag for setting time
short int *timeValue;   // A pointer to write data into a struct, no matter which one (explanation later)

int terrNumSelected = 1;        // For figuring out which terr to acess
int terrNums[3] = { 1, 2, 3 };  // Defines the amount of terrs in system. for 2: {1, 2, 0}, for 1: {1, 0, 0}
char terrNumStr[2] = { 0 };     // Char for int to char conversion
int terrCount = 0;  // To calculate how many terrs were defined

Terr terr1;   //
Terr terr2;   // Initialise the terrs
Terr terr3;   //

Terr terrsList[3] = { terr1, terr2, terr3 };  // Array of terrs to acess in the program

//----------------------------------------------------------Init-Terrs-----------------------------------------------------------//

void initTerrs() {  // Initialises the pins an adresses for each terr
  terrsList[0].tempHumAddr1 = 0;
  terrsList[0].tempHumAddr2 = 1;
  terrsList[1].tempHumAddr1 = 2;
  terrsList[1].tempHumAddr2 = 3;
  terrsList[2].tempHumAddr1 = 4;
  terrsList[2].tempHumAddr2 = 5;

  terrsList[0].light.heatPin = 11;
  terrsList[1].light.heatPin = 10;
  terrsList[2].light.heatPin = 9;

  pinMode(terrsList[0].light.heatPin, OUTPUT);
  pinMode(terrsList[1].light.heatPin, OUTPUT);
  pinMode(terrsList[2].light.heatPin, OUTPUT);
}

//----------------------------------------------------------Get-Current----------------------------------------------------------//

// This block works with the power monitors to not5ise if a heat lamp has burned out
// Main Idea: if current drops - a lamp is dead, throw an error 

int ini_mA;
int mA;

bool currentMeasure[3] = {0, };   // To measure the initial current ONCE
ACS712 *ACS;                      // A pointer to a power monitor
ACS712 ACS1(12, 5.0, 1023, 100);    //  
ACS712 ACS2(13, 5.0, 1023, 100);    // Defines The power monitors PINS: 12 for T1, 13 for T2, 14 for T3
ACS712 ACS3(14, 5.0, 1023, 100);    //

void getCurrent() {   // Does all the current measurements

  short int errCode;  // Prepares an error code if a lamp is found dead
  for (int i = 0; i < 3; i++) {   // Cycles through all power monitors
    switch (i) {  // Uses the pointer to avoid writing the same code three times
      case 0:
        ACS = &ACS1;
        break;
      case 1:
        ACS = &ACS2;
        break;
      case 2:
        ACS = &ACS3;
        break;
    }

    if (terrsList[i].light.isHeat && !terrsList[i].light.isHeatOff) {   
      // If the lamp in the selected terr is on by timer and NOT manually tuned off:
      if (!currentMeasure[i]) {     // If the initial current hasn't yet been measured
        ACS->autoMidPoint();            // From working library example, not sure what it does but it's important
        ini_mA = ACS->mA_AC(50, 1);     // Get current current (LOL)
        Serial.print("INITIAL CURRENT: ");
        Serial.println(ini_mA);
        currentMeasure[i] = true;   
      } else {
        mA = ACS->mA_AC(50, 1);  // The AC Frequency = 50Hz, Measure 1 Cycle
        Serial.printf("Current AC in terr %d: ", i + 1); 
        Serial.print(mA);
        Serial.println(" mA");

        if (abs(mA) < (ini_mA / 2)) { // TODO: Recalculate the treshhold math for real world situation
          // If the current is Significantly lower than before
          //Serial.printf("AHTUNG terr %d\n", i+1);
          sprintf(errMsg, "T%d-Lamp Fail", i + 1);  // Writes the error message to storage
          errCode = i + 1 + 6;
          createErr(errCode); // Creates a new error
        }
      }
    } else currentMeasure[i] = false;
  }
}

//----------------------------------------------------------Test-Dimmer----------------------------------------------------------//

// This block is TEMPORARY. It serves only for proof of concept with a very bad dimmer module 
// (because good ones are still in shipping) so commentary is not really necessary
// Main idea: changeDimmer() changes the brightness of the LED lights

#include <DigiPotX9Cxxx.h>

#define INC 39
#define UD 40
#define CS 41
 
DigiPot X9C(INC, UD, CS); // Pins:(INC, U/D, CS)
int dimmerVal = 1;
int dimmerValCounter = 5;
bool isDimmerRising = true;

void changeDimmer() {
  if (isDimmerRising) {
    if (dimmerVal == 99) isDimmerRising = false;
    else {
      if (dimmerValCounter == 5) {
        dimmerValCounter = 1;
        dimmerVal ++;
        X9C.increase(1);
        Serial.println(dimmerVal);
      }
      else dimmerValCounter ++;
    }
  }
  else {
    if (dimmerVal == 1) isDimmerRising = true;
    else {
      if (dimmerValCounter == 5) {
        dimmerValCounter = 1;
        dimmerVal --;
        X9C.decrease(1);
        Serial.println(dimmerVal);
      }
      else dimmerValCounter ++;
    }
  }
}

//-----------------------------------------------------------Get-Time------------------------------------------------------------//

// This block is a WIP. For some reason the RTC module doesn't show up. Probably because of the Adafuit library
// For now the time is fake (which is better because you can speed it up for testing purpouses)

#include <RTClib.h>  //"Adafruit BusIO" required for use

RTC_DS3231 rtc;   // Init RTC

uint32_t HOUR;  //iniialise variables
uint32_t MIN;
uint32_t SEC;

short int mainHours = 0;        //
short int mainMinutes = 0;      //
short int mainDay = 1;          // Default date & time
short int mainMonth = 1;        //
short int mainYear = 2025;      //
short int daysInMonth[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
char mainDateVal[9];
short int mainDate[3] = {0, };

char mainTimeVal[3] = {0, };

unsigned long int currMainTime = 0;

char daysOfTheWeek[7][24] = { "Воскресенье", "Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота" };  //create massive of weekdays

uint32_t getSeconds(uint32_t HOUR, uint32_t MIN, uint32_t SEC) {
  return ((HOUR * 3600) + (MIN * 60) + SEC);
}

void getTime() { // Currently not working
  TCA9548A(3);

  DateTime now = rtc.now();
  uint32_t SEC_TIME = getSeconds(now.hour(), now.minute(), now.second());

  // uint32_t HOUR = now.hour();
  // uint32_t MIN = now.minute();
  // uint32_t SEC = now.second();

  // uint32_t SEC_TIME = ((HOUR * 3600) + (MIN * 60) + SEC);

  Serial.print(now.year(), DEC);
  Serial.print('/');
  Serial.print(now.month(), DEC);
  Serial.print('/');
  Serial.print(now.day(), DEC);
  Serial.print(" (");
  Serial.print(daysOfTheWeek[now.dayOfTheWeek()]);
  Serial.print(") ");


  if (now.hour() < 10) {
    Serial.print("0");
  }
  Serial.print(now.hour(), DEC);
  Serial.print(':');
  if (now.minute() < 10) {
    Serial.print("0");
  }
  Serial.print(now.minute(), DEC);
  Serial.print(':');

  if (now.second() < 10) {
    Serial.print("0");
  }
  Serial.print(now.second(), DEC);

  Serial.print(" ");
  Serial.print(SEC_TIME);
  Serial.println();
}

void setTimeTemp() {  // Adds 1 to the current date+Time and correclty shifts hours, days, etc. Just math basically
  if (!(selectedWindow == 9 && prevWindow == 1)) {
    if (millis() - currMainTime >= 10) {
      currMainTime = millis();
      if (mainMinutes < 59) mainMinutes++;
      else {
        mainMinutes = 0;
        if (mainHours < 23) mainHours++;
        else {
          mainHours = 0;
          if (mainDay < daysInMonth[mainMonth - 1]) mainDay++;
          else {
            mainDay = 1;
            if (mainMonth < 12) mainMonth++;
            else {
              mainMonth = 1;
              mainYear++;
            }
          }
        }
      }
    }
  }
}

//--------------------------------------------------------Get-Temp+Humid---------------------------------------------------------//

// This block is for reading and processing the temperature and humidity sensors

unsigned long int currTime = 0;  // Current time to compare to millis (or a RTM)
double tempSeed = 0;             // X value for the sine curves. Needed until emperature and humidity sensor data will be integrated

char temp1_char[5] = {0, }; // Char arrays to convert the sensor value to a printable char
char temp2_char[5] = {0, }; //
char hum1_char[5] = {0, };  //
char hum2_char[5] = {0, };  //

void getTempAndHum() {  // Fetches latest temperature and humidity data 

  short int errCode;

  for (int i = 0; i < terrCount; i++) { // Does this for all terrariums
    terrsList[i].tempMax = 1;    // Reset of min and max values to update them every data capture
    terrsList[i].tempMin = 100;  //
    terrsList[i].humMax = 1;     //
    terrsList[i].humMin = 101;   //

    terrsList[i].temp1 = readTemperature(terrsList[i].tempHumAddr1);  // Reads the data from temp sensor 1
    if (terrsList[i].temp1 == -999) {   // Catches "Not found" error and creates it
      sprintf(errMsg, "THS%d NotFound", i * 2 + 1);
      errCode = i * 2 + 1;
      createErr(errCode);
    } else {
      for (int j = 0; j < 48; j++) {   
        if (j < 47) terrsList[i].temp1Storage[j] = terrsList[i].temp1Storage[j + 1];        
        else terrsList[i].temp1Storage[j] = terrsList[i].temp1;
         // Shifts the whole data storage one to the left and adds the last capture to the end
        if (terrsList[i].temp1Storage[j] > terrsList[i].tempMax) terrsList[i].tempMax = terrsList[i].temp1Storage[j];  
        if (terrsList[i].temp1Storage[j] < terrsList[i].tempMin) terrsList[i].tempMin = terrsList[i].temp1Storage[j];
        // Recalculates the max and min temperature based on the new set
      }
    }
    
    // The following code is the same but for other sensors of the terrarium

    terrsList[i].temp2 = readTemperature(terrsList[i].tempHumAddr2);
    if (terrsList[i].temp2 == -999) {
      sprintf(errMsg, "THS%d NotFound", i * 2 + 2);
      errCode = i * 2 + 2;
      createErr(errCode);
    } else {
      for (int j = 0; j < 48; j++) {                                                         
        if (j < 47) terrsList[i].temp2Storage[j] = terrsList[i].temp2Storage[j + 1];         
        else terrsList[i].temp2Storage[j] = terrsList[i].temp2;                                           
        if (terrsList[i].temp2Storage[j] > terrsList[i].tempMax) terrsList[i].tempMax = terrsList[i].temp2Storage[j];  
        if (terrsList[i].temp2Storage[j] < terrsList[i].tempMin) terrsList[i].tempMin = terrsList[i].temp2Storage[j];  
      }
    }

    terrsList[i].hum1 = readHumidity(terrsList[i].tempHumAddr1);
    if (terrsList[i].hum1 == -999) {
      sprintf(errMsg, "THS%d NotFound", i * 2 + 1);
      errCode = i * 2 + 1;
      createErr(errCode);
    } else {
      for (int j = 0; j < 48; j++) {                                                     
        if (j < 47) terrsList[i].hum1Storage[j] = terrsList[i].hum1Storage[j + 1];       
        else terrsList[i].hum1Storage[j] = terrsList[i].hum1;                                         
        if (terrsList[i].hum1Storage[j] > terrsList[i].humMax) terrsList[i].humMax = terrsList[i].hum1Storage[j];  
        if (terrsList[i].hum1Storage[j] < terrsList[i].humMin) terrsList[i].humMin = terrsList[i].hum1Storage[j];  
      }
    }

    terrsList[i].hum2 = readHumidity(terrsList[i].tempHumAddr2);
    if (terrsList[i].hum2 == -999) {
      sprintf(errMsg, "THS%d NotFound", i * 2 + 2);
      errCode = i * 2 + 2;
      createErr(errCode);
    } else {
      for (int j = 0; j < 48; j++) {                                                     
        if (j < 47) terrsList[i].hum2Storage[j] = terrsList[i].hum2Storage[j + 1];       
        else terrsList[i].hum2Storage[j] = terrsList[i].hum2;                                         
        if (terrsList[i].hum2Storage[j] > terrsList[i].humMax) terrsList[i].humMax = terrsList[i].hum2Storage[j];  
        if (terrsList[i].hum2Storage[j] < terrsList[i].humMin) terrsList[i].humMin = terrsList[i].hum2Storage[j];  
      }
    }
  }
  
  /*
  // Data readout for debugging
  for (int i = 0; i < 48; i++) {
    Serial.print(terrsList[0].temp1Storage[i]);
    Serial.print("  ");
    Serial.print(terrsList[0].temp2Storage[i]);
    Serial.print("  ");
    Serial.print(terrsList[0].hum1Storage[i]);
    Serial.print("  ");
    Serial.print(terrsList[0].hum2Storage[i]);
    Serial.println("");
  }
  */
}

int readTemperature(uint8_t addr) {  //создаем функцию чтения температуры с датчика
  TCA9548A(addr);

  Wire.beginTransmission(0x40);  //начинаем связь между контроллером и датчиком по I2C
  Wire.write(0xF3);              //отправляем команду измерения температуры 0xF3(no hold master), 0xE3(hold master)
  Wire.endTransmission();        //оканчиваем связь(обязательный пункт, чтобы устройства не транслировали другие данные)
  delay(100);

  Wire.requestFrom(0x40, 3);              //запрашиваем данные с датчика
  if (Wire.available() < 3) return -999;  //датчик возвращает значение, если на нем слишком мало инфы

  uint16_t temp = Wire.read() << 8;  //объединение битовых масок
  temp |= Wire.read();
  Wire.read();

  return round(-46.85 + 175.72 * (temp / 65536.0));  //формула перевда данных в градусы цельсия
}

int readHumidity(uint8_t addr) {  //создаем функцию чтения влажности с датчика
  TCA9548A(addr);

  Wire.beginTransmission(0x40);
  Wire.write(0xF5);  //отправляем команду измерения влажности 0xF5(no hold master), 0xE5(hold master)
  Wire.endTransmission();
  delay(100);

  Wire.requestFrom(0x40, 3);
  if (Wire.available() < 3) return -999;

  uint16_t hum = Wire.read() << 8;
  hum |= Wire.read();
  Wire.read();

  return round(-6 + 123 * (hum / pow(2, 16)));  //расчет температуры
}

void TCA9548A(uint8_t bus) {   // Switches the multiplexer bus to the correct address
  Wire.beginTransmission(0x70);  // TCA9548A address is 0x70
  Wire.write(1 << bus);          // send byte to select bus
  Wire.endTransmission();
  //Serial.println(bus);
}

//-------------------------------------------------------Light-Heat-Control------------------------------------------------------//

// This block handles Heat and LED lamp control

void toggleHeat() {
  for (int i = 0; i < 3; i++) { // Does this for all terrariums
    if (terrsList[i].daylightHours[0] * 60 + terrsList[i].daylightMinutes[0] <= mainHours * 60 + mainMinutes && mainHours * 60 + mainMinutes <= terrsList[i].daylightHours[1] * 60 + terrsList[i].daylightMinutes[1] && !terrsList[i].light.isHeatOff) terrsList[i].light.isHeat = true;
    if (terrsList[i].daylightHours[1] * 60 + terrsList[i].daylightMinutes[1] <= mainHours * 60 + mainMinutes || mainHours * 60 + mainMinutes <= terrsList[i].daylightHours[0] * 60 + terrsList[i].daylightMinutes[0]) terrsList[i].light.isHeat = false;
    // If right now is within the set heat shedule - Turn the light on, otherwise, turn it off

    if (!terrsList[i].light.isHeatOff && terrsList[i].light.isHeat) digitalWrite(terrsList[i].light.heatPin, LOW);
    // If the heat should be on by shedule and isn't manually turned off - turn the heat relay on. (LOW = ON)
    else digitalWrite(terrsList[i].light.heatPin, HIGH);
  }
}

void toggleLight() { // The same as for toggleHeat but for LED lights
  for (int i = 0; i < 3; i++) {
    if (terrsList[i].daylightHours[2] * 60 + terrsList[i].daylightMinutes[2] <= mainHours * 60 + mainMinutes && mainHours * 60 + mainMinutes <= terrsList[i].daylightHours[3] * 60 + terrsList[i].daylightMinutes[3] && !terrsList[i].light.isLightOff) terrsList[i].light.isLight = true;
    if (terrsList[i].daylightHours[3] * 60 + terrsList[i].daylightMinutes[3] <= mainHours * 60 + mainMinutes || mainHours * 60 + mainMinutes <= terrsList[i].daylightHours[2] * 60 + terrsList[i].daylightMinutes[2]) terrsList[i].light.isLight = false;

    if (!terrsList[i].light.isLightOff) digitalWrite(terrsList[i].light.lightPin, LOW);
    else digitalWrite(terrsList[i].light.lightPin, HIGH);
  }
}

//-----------------------------------------------------------Init-Menu-----------------------------------------------------------//

// This block handles backed calculations that don't depend on the active window

void drawBorder() {                                  // Draws the main window border
  u8g2.setColorIndex(1);                             // 1 == fill, 0 == no fill
  u8g2.drawFrame(0, 0, scrW - 2 * 0, scrH - 2 * 0);  //
  u8g2.setColorIndex(0);                             //
  u8g2.drawBox(1, 1, scrW - 2 * 1, scrH - 2 * 1);    // Clears everything whithin the border
  u8g2.setColorIndex(1);                             //
}

void drawHeader(char *header) {         // Draws a window header with scpecified text
  u8g2.setColorIndex(0);                //
  u8g2.drawBox(1, 1, scrW - 2 * 1, 9);  //
  u8g2.setColorIndex(1);                //
  u8g2.drawStr(2, 9, header);           //
  u8g2.drawLine(0, 10, scrW, 10);       //
}

void drawPicture(short int x, short int y, short int w, short int h, bool *bitmap) {
  // For some reason the drawBMP() method in the u8g2 library doesn't work. So we made our own
  u8g2.setColorIndex(0);      //
  u8g2.drawBox(x, y, w, h);   // Clears the background of the image (ColorIndex 0 = erase, 1 = draw)
  u8g2.setColorIndex(1);      //

  for (int i = 0; i < h; i++) {
    for (int j = 0; j < w; j++) { // Goes through the columns of the image row by row 
      if (bitmap[w * i + j] && !isInverted) u8g2.drawPixel(x + j, y + i); 
      // Draws a pixel if the source bitmap has a 1 and isn't inverted

      if (!bitmap[w * i + j] && isInverted) u8g2.drawPixel(x + j, y + i);
      // Draws a pixel if the source bitmap has a 0 and is inverted
    }
  }
}

void drawDate(int x, int y, short int date[3]) {    // Draws the current date at a given location "DD.MM.YY"

  sprintf(mainDateVal, "%02d", date[0]);
  u8g2.drawStr(x, y, mainDateVal);
  u8g2.drawPixel(x + 12, y - 1);
  sprintf(mainDateVal, "%02d", date[1]);
  u8g2.drawStr(x + 14, y, mainDateVal);
  u8g2.drawPixel(x + 14 + 12, y - 1);
  sprintf(mainDateVal, "%02d", date[2] - 2000);
  u8g2.drawStr(x + 14 + 14, y, mainDateVal);
}

void errFlash(bool isReset) {     // Changes certain bitmaps based on a timer to "Flash an error"
  if (isReset) isErrFlashDisplayed = true;

  if (millis() - errTimer >= 1000) {
    if (isErrFlashDisplayed) {
      for (int i = 0; i < 36; i++) back_arrow_bitmap[i] = back_arrow_bitmap_og[i];
      for (int i = 0; i < 529; i++) error_bitmap[i] = error_bitmap_og[i];
      isErrFlashDisplayed = false;
    } else {
      for (int i = 0; i < 36; i++) back_arrow_bitmap[i] = warn_bitmap_og[i];
      for (int i = 0; i < 529; i++) error_bitmap[i] = error_highl_bitmap_og[i];
      isErrFlashDisplayed = true;
    }
    errTimer = millis();
  }
}

void createErr(short int code) {    // Creates a new error
  if (errCodes[code] != 1) {  // If this particular error hasn't already been created
    errCodes[code] = 1; // The codes array now shows that this error now exists

    errCodePositions[getLastErrIndex() + 1] = code;       // Stores the error position
    errDates[getLastErrIndex() + 1][0] = mainDay;     // 
    errDates[getLastErrIndex() + 1][1] = mainMonth;   // Stores the error date
    errDates[getLastErrIndex() + 1][2] = mainYear;    //
    sprintf(errMessages[getLastErrIndex() + 1], errMsg);  // Stores the error message

    /*
    // Debugging
    Serial.println("ADDING");
    Serial.printf("RTC = %d, THS1 = %d, THS2 = %d, THS3 = %d, THS4 = %d, THS5 = %d, THS6 = %d, T1LF = %d, T2LF = %d, T3LF = %d, 10 = %d, 11 = %d, 12 = %d", errCodes[0], errCodes[1], errCodes[2], errCodes[3], errCodes[4], errCodes[5], errCodes[6], errCodes[7], errCodes[8], errCodes[9], errCodes[10], errCodes[11]);
    Serial.println("");

    for (int i = 0; i <= getLastErrIndex()+1; i++) {
      Serial.print(errCodePositions[i]);
      Serial.print(",   ");
      Serial.print(errMessages[i]);
      Serial.print(",   ");
      Serial.print(errDates[i][0]);
      Serial.print(",");
      Serial.print(errDates[i][1]);
      Serial.print(",");
      Serial.println(errDates[i][2]);
    }
    */
  }
}

void onClickInterrupt(int buttonId) {   
  // Calls a function appropriate to the active window and passes on which button was pressed 
  // (rotating the encoder in a direction is equvalent to a button press)
  if (millis() - currButtonTime > debounceTime || buttonId != 2) {   
    // Skips the function call if encoder button is still in debounce
    currButtonTime = millis();
    switch (selectedWindow) {
      case 1:
        onClickMM(buttonId);
        break;
      case 2:
        onClickTH(buttonId);
        break;
      case 3:
        onClickLH(buttonId);
        break;
      case 4:
        onClickEM(buttonId);
        break;
      case 5:
        onClickDC(buttonId);
        break;
      case 6:
        onClickSS(buttonId);
        break;
      case 7:
        onClickWP(buttonId);
        break;
      case 8:
        onClickEF(buttonId);
        break;
      case 9:
        onClickST(buttonId);
        break;
      case 10:
        onClickSTWP(buttonId);
        break;
      default:
        break;  //ERROR: WEIRD SHIT. do later
    }
  }
}

// isrA() and isrB() work together to determine the rotation direction of the encoder

void isrA() {
  if (readB != readA) {
    count++;
    onClickInterrupt(1);    // Rot. counterclockwise
  } else {
    count--;
    onClickInterrupt(3);    // Rot. clockwise
  }
}
void isrB() {
  if (readA == readB) {
    count++;
    onClickInterrupt(1);    // Rot. counterclockwise
  } else {
    count--;
    onClickInterrupt(3);    // Rot. clockwise
  }
}

void encoderButton_ISR() {  
  // Calls a button press (function in function because interrupts don't allow passing arguments)
  onClickInterrupt(2);    // Button press
}

void selectArrow(bool isLeft) {   // Flags that an arrow has been selected

  cursorX = 0;  
  cursorY = 0;  
  cursorW = 1;  
  cursorH = 1;

  if (isLeft) {
    selectedLeftArrow = true;
    selectedRightArrow = false;
  } else {
    selectedRightArrow = true;
    selectedLeftArrow = false;
  }
}

void selectReturn() {     // Flags that the return arrow has been selected
  cursorX = scrW - 9;  
  cursorY = scrH - 9;  
  cursorW = 8;         
  cursorH = 8;
}

int getCurrentTerrIndex() {     // Gets the index of an arry elemnt that matches a certain value

  for (int i = 0; i < 3; i++)
    if (terrNums[i] == terrNumSelected) return i;
}

int getLastErrIndex() {   // Gets the latest error position 

  int currentIndex = -1;
  for (int i = 0; i < 64; i++)
    if (errMessages[i][1] != '\0') currentIndex = i;
  return currentIndex;
}

void switchTerr(bool toLeft) {   // Switches between terrs to apply settings changes
  int selectedIndex = 0;
  int newSelectedIndex = 0;

  if (terrCount == 0) {
    Serial.println("ERROR: NO TERRS");  //Do proper error later
    return;
  }
  if (terrCount == 1) return;

  if (toLeft) { // Loops between terrr indexes in both diretions
    if (getCurrentTerrIndex() == 0) {
      for (int i = 0; i < 3; i++)
        if (terrNums[i] != 0) newSelectedIndex = i;
      terrNumSelected = terrNums[newSelectedIndex];
    } else terrNumSelected = terrNums[getCurrentTerrIndex() - 1];
  } else {
    if (terrCount == 3 && getCurrentTerrIndex() == 2) {
      terrNumSelected = terrNums[0];
    } else {
      if (terrCount == 2 && getCurrentTerrIndex() == 1) {
        terrNumSelected = terrNums[0];
      } else terrNumSelected = terrNums[getCurrentTerrIndex() + 1];
    }
  }
}

void onClickST(int n) { // The button presses when setting a time value
  switch (n) {
    case 1:   // Rot counterclockwise. 
      editTimeValue(false); // Decrease selected time component
      break;
    case 2:   // Button press
      if (isHours) isHours = false;   // Switches from editing hours to editing minutes
      else {
        isHours = true;
        selectedWindow = prevWindow;   // Returns to previous window
      }
      break;
    case 3:  // Rot clockwise. 
      editTimeValue(true);    // Increase selected time component
      break;
  }
}

// Михаил Сергеевич, если вы действительно читаете код и комментарии, во-первых наше почтение, надеюсь мы не
// принесли вам много головной боли. Во-вторых, было бы приятно если бы вы потом в разговоре упомянули ананасы.

void editTimeValue(bool isRising) {   // Actually changes the selected time value
  switch (prevWindow) {   // Selects address to assign to pointer: what to change
    case 1:   // If in Main Menu
      if (isHours) timeValue = &mainHours;  //  Changes main hours and minutes
      else timeValue = &mainMinutes;        //
      break;
    case 5:   // If in Daylight Cycle, change Daylight hours and minutes of the selected item
      if (isHours) timeValue = &terrsList[getCurrentTerrIndex()].daylightHours[selectedItem - 3]; 
      // [selectedItem - 3] becuse s.i. starts from 1 and s.i. 1 and 2 are reserved
      else timeValue = &terrsList[getCurrentTerrIndex()].daylightMinutes[selectedItem - 3];
      break;
    case 6:   // If in Sunrise & Sunset, change Sunrise hours and minutes of the selected item
      if (isHours) timeValue = &terrsList[getCurrentTerrIndex()].sunriseHours[selectedItem - 3];
      else timeValue = &terrsList[getCurrentTerrIndex()].sunriseMinutes[selectedItem - 3];
      break;
    default:
      break;
  }

  if (isHours) {  // Math to prevent overflow (i.e. 0<= Hours<= 23)
    if (isRising) {
      if (*timeValue >= 23) *timeValue = 0;
      else *timeValue += 1;
    } else {
      if (*timeValue <= 0) *timeValue = 23;
      else *timeValue -= 1;
    }
  } else {
    if (isRising) {
      if (*timeValue >= 59) *timeValue = 0;
      else *timeValue += 1;
    } else {
      if (*timeValue <= 0) *timeValue = 59;
      else *timeValue -= 1;
    }
  }
}

void onClickSTWP(int n) {   // The button presses when setting a time value in Winter Prep
  // In Winter Prep the time value is only hours, so changing it is way more simple than in the above cases
  switch (n) {
    case 1:
      if (terrsList[getCurrentTerrIndex()].winterDays[terrsList[getCurrentTerrIndex()].dayNumSelected - 1] > 0) terrsList[getCurrentTerrIndex()].winterDays[terrsList[getCurrentTerrIndex()].dayNumSelected - 1]--;
      break;
    case 2:
      selectedWindow = prevWindow;
      break;
    case 3:
      if (terrsList[getCurrentTerrIndex()].winterDays[terrsList[getCurrentTerrIndex()].dayNumSelected - 1] < 24) terrsList[getCurrentTerrIndex()].winterDays[terrsList[getCurrentTerrIndex()].dayNumSelected - 1]++;
  }
}

//-----------------------------------------------------------Main-Menu-----------------------------------------------------------//

void calculateMainMenu() {  // Sets the initial Cursor position
  switch (selectedItem) {
    case 1:
      cursorX = 14;  
      cursorY = 11;  
      cursorW = 37;  
      cursorH = 25;  
      break;
    case 2:
      cursorX = 84;  
      cursorY = 11;  
      cursorW = 25;  
      cursorH = 25;  
      break;
    case 3:
      cursorX = 20;  
      cursorY = 38;  
      cursorW = 25;  
      cursorH = 25;  
      break;
    case 4:
      cursorX = 84;  
      cursorY = 38;  
      cursorW = 25;  
      cursorH = 25;  
      break;
    case 5:
      cursorX = scrW - 1 - 33;  
      cursorY = 1;              
      cursorW = 33;             
      cursorH = 9;
      break;
    default:
      break;
  }
}

void openMainMenu() {  // Prints out the 'Main Menu' window

  drawBorder();
  drawHeader("Main");
  u8g2.drawLine(64, 10, 64, scrH);
  u8g2.drawLine(0, 36, scrW, 36);
  u8g2.drawLine(63, 10, 63, scrH);
  u8g2.drawLine(0, 37, scrW, 37);

  drawPicture(21 - 6, 12, 35, 23, temp_humid_bitmap);
  drawPicture(21 + 64, 12, 23, 23, light_bitmap);
  drawPicture(21, 12 + 27, 23, 23, error_bitmap);
  drawPicture(21 + 64, 12 + 27, 23, 23, day_night_bitmap);

  if (selectedWindow == 1) u8g2.drawFrame(cursorX, cursorY, cursorW, cursorH);
  else {    // If you are setting the time, it highlights the component being edited
    if (isHours) u8g2.drawBox(cursorX, cursorY, cursorW - 18, cursorH); 
    else u8g2.drawBox(cursorX + 18, cursorY, cursorW - 18, cursorH);
  }

  drawTimeMM();
}

void onClickMM(int n) {  // Check for button presses and do something about it

  switch (n) {  // All possible button actions
    case 1:
      if (selectedItem == 1) selectedItem = 5;
      else selectedItem--;
      break;
    case 2:
      switch (selectedItem) {  // Opens a different window depending on the item selected
        case 1:
          selectReturn();
          selectedWindow = 2;   // Opens Temperature & Humidity
          selectedItem = 1;
          break;
        case 2:
          selectReturn();
          selectedWindow = 3;   // Opens Light & Heat
          selectedItem = 1;
          break;
        case 3:
          selectReturn();
          selectedWindow = 4;   // Opens Error Menu
          selectedItem = 1;
          break;
        case 4:
          selectReturn();
          selectedWindow = 5;   // Opens Daylight Cycle
          selectedItem = 1;
          break;
        case 5:
          selectedWindow = 9;   // Sets main Time, remebers that it came from Main Menu
          prevWindow = 1;       //
          break;
        default:
          //ERROR WEIRD SHIT! do later.
          break;
      }
      break;
    case 3:  //
      if (selectedItem == 5) selectedItem = 1;
      else selectedItem++;
      break;
    default:
      break;  //ERROR WEIRD SHIT! do later.
  }

  //Serial.println(selectedItem);
}

void drawTimeMM() {
  if (selectedWindow == 9 && selectedItem == 5 && isHours) u8g2.setColorIndex(0);   
  // If this is the component being edited, "erases" the text from the drawn box

  sprintf(mainTimeVal, "%02d", mainHours);
  u8g2.drawStr(scrW - 1 - 31, 9, mainTimeVal);

  u8g2.setColorIndex(1);

  drawPicture(scrW - 1 - 31 + 14, 9 - 6, 1, 5, colon_bitmap);

  if (selectedWindow == 9 && selectedItem == 5 && !isHours) u8g2.setColorIndex(0);

  sprintf(mainTimeVal, "%02d", mainMinutes);
  u8g2.drawStr(scrW - 1 - 31 + 18, 9, mainTimeVal);

  u8g2.setColorIndex(1);

  mainDate[0] = mainDay;
  mainDate[1] = mainMonth;
  mainDate[2] = mainYear;

  drawDate(scrW - 1 - 31 - 36 - 10, 9, mainDate);
}

//-----------------------------------------------------------Temp-Humid----------------------------------------------------------//

void calculateTempHumid() {
  sprintf(temp1_char, "%d", terrsList[getCurrentTerrIndex()].temp1);  //
  sprintf(temp2_char, "%d", terrsList[getCurrentTerrIndex()].temp2);  //
  sprintf(hum1_char, "%d", terrsList[getCurrentTerrIndex()].hum1);    // Prepares the data to write
  sprintf(hum2_char, "%d", terrsList[getCurrentTerrIndex()].hum2);    //
  sprintf(terrNumStr, "%d", terrNumSelected);                         //

  switch (selectedItem) {   // Sets cursor position
    case 1:
      selectedLeftArrow = false;
      selectedRightArrow = false;
      selectReturn();
      break;
    case 2:
      selectArrow(true);
      break;
    case 3:
      selectArrow(false);
      break;
    default:
      break;
  }
}

void openTempHumid() {  // Draws the 'Temperature & Humidity' window

  u8g2.drawFrame(cursorX, cursorY, cursorW, cursorH);

  drawBorder();
  drawHeader("Temperatue & Humidity");
  u8g2.drawLine(34, 10, 34, scrH);
  u8g2.drawLine(86, 10, 86, scrH);
  u8g2.drawLine(8, 36, scrW - 8, 36);

  u8g2.drawLine(8, 10, 8, scrH - 10);
  u8g2.drawLine(scrW - 8, 10, scrW - 8, scrH - 10);

  u8g2.drawFrame(118, 54, 10, 10);  
  u8g2.drawFrame(0, 54, 10, 10);

  u8g2.drawStr(3, scrH - 1, terrNumStr);

  // Dynamically displays the current temperature from sensor 1
  u8g2.drawStr(88, 21, "1");  
  drawPicture(88 + 7, 21 - 5, 1, 5, colon_bitmap);
  u8g2.drawStr(88 + 10, 21, temp1_char);  
  u8g2.drawStr(88 + 10 + 14, 21, "C");    

  u8g2.drawLine(36, 12, 36, 34);       
  u8g2.drawLine(36, 34, 36 + 48, 34);  // Displays the 24h data log as a graph with autoscale due to map()
  for (int i = 0; i < 48; i++) u8g2.drawPixel(37 + i, map(terrsList[getCurrentTerrIndex()].temp1Storage[i], terrsList[getCurrentTerrIndex()].tempMin / 2, terrsList[getCurrentTerrIndex()].tempMax, 33, 13));

  // Same only for temperature sensor 2
  u8g2.drawStr(88, 33, "2");                        
  drawPicture(88 + 7, 33 - 5, 1, 5, colon_bitmap);  
  u8g2.drawStr(88 + 10, 33, temp2_char);            
  u8g2.drawStr(88 + 10 + 14, 33, "C");

  for (int i = 0; i < 48; i++) u8g2.drawPixel(37 + i, map(terrsList[getCurrentTerrIndex()].temp2Storage[i], terrsList[getCurrentTerrIndex()].tempMin / 2, terrsList[getCurrentTerrIndex()].tempMax, 33, 13));

  // Same only for humidity sensor 1
  u8g2.drawStr(88, 47, "1");                        
  drawPicture(88 + 7, 47 - 5, 1, 5, colon_bitmap);  
  u8g2.drawStr(88 + 10, 47, hum1_char);             
  u8g2.drawStr(88 + 10 + 14, 47, "%");              
                                                    
  u8g2.drawLine(36, 38, 36, 61);                    
  u8g2.drawLine(36, 61, 36 + 48, 61);

  for (int i = 0; i < 48; i++) u8g2.drawPixel(37 + i, map(terrsList[getCurrentTerrIndex()].hum1Storage[i], terrsList[getCurrentTerrIndex()].humMin / 2, terrsList[getCurrentTerrIndex()].humMax, 60, 39));

  // Same only for humidity sensor 2
  u8g2.drawStr(88, 59, "2");                        
  drawPicture(88 + 7, 59 - 5, 1, 5, colon_bitmap);  
  u8g2.drawStr(88 + 10, 59, hum2_char);             
  u8g2.drawStr(88 + 10 + 14, 59, "%");              

  for (int i = 0; i < 48; i++) u8g2.drawPixel(37 + i, map(terrsList[getCurrentTerrIndex()].hum2Storage[i], terrsList[getCurrentTerrIndex()].humMin / 2, terrsList[getCurrentTerrIndex()].humMax, 60, 39));

  drawPicture(10, 12, 23, 23, temperature_bitmap);
  drawPicture(10, 38, 23, 23, humidity_bitmap);

  if (selectedLeftArrow) drawPicture(1, 22, 6, 20, left_arrow_bitmap);
  else drawPicture(1, 22, 6, 20, left_arrow_empty_bitmap);
  if (selectedRightArrow) drawPicture(121, 22, 6, 20, right_arrow_bitmap);
  else drawPicture(121, 22, 6, 20, right_arrow_empty_bitmap);
  drawPicture(120, 56, 6, 6, back_arrow_bitmap);

  u8g2.drawFrame(cursorX, cursorY, cursorW, cursorH);
}

void onClickTH(int n) {  // Checks if the middle button is pressed to return to the main menu

  switch (n) {
    case 1:
      if (selectedItem == 1) selectedItem = 4;
      else selectedItem--;
      break;
    case 2:
      switch (selectedItem) {
        case 1:
          selectedItem = 1;   // Returns to Main Menu
          selectedWindow = 1;
          break;
        case 2:
          switchTerr(true);
          break;
        case 3:
          switchTerr(false);
          break;
        default:
          break;
      }
      break;
    case 3:  //
      if (selectedItem == 4) selectedItem = 1;
      else selectedItem++;
      break;
    default:
      break;
  }
}

//-----------------------------------------------------------Light&Heat----------------------------------------------------------//

void calculateLightHeat() {
  sprintf(terrNumStr, "%d", terrNumSelected);   // Prepares the data to write

  if (selectedItem != 2 && selectedItem != 5) {
    selectedLeftArrow = false;
    selectedRightArrow = false;
  }

  switch (selectedItem) {   // Sets cursor position
    case 1:
      selectReturn();
      break;
    case 2:
      selectArrow(true);
      break;
    case 3:
      cursorX = 11;
      cursorY = 12;
      cursorH = 50;
      cursorW = 50;
      break;
    case 4:
      cursorX = 11 + 50 + 6;
      cursorY = 12;
      cursorH = 50;
      cursorW = 50;
      break;
    case 5:
      selectArrow(false);
      break;
    default:
      break;  //ERROR WEIRD SHIT! do later.
  }
}

void openLightHeat() {                          

  drawBorder();
  drawHeader("Light & Heat");

  u8g2.drawLine(7, 10, 7, scrH - 10);
  u8g2.drawLine(scrW - 8, 10, scrW - 8, scrH - 10);

  u8g2.drawFrame(118, 54, 10, 10);  // Places an immovable (while only 1 terrarium in stack) cursor that can only lead back to the main menu
  u8g2.drawFrame(0, 54, 10, 10);

  u8g2.drawStr(3, scrH - 1, terrNumStr);

  drawPicture(12, 13, 48, 48, heat_bitmap);
  drawPicture(68, 13, 48, 48, light_big_bitmap);

  if (selectedLeftArrow) drawPicture(1, 22, 6, 20, left_arrow_bitmap);
  else drawPicture(1, 22, 6, 20, left_arrow_empty_bitmap);
  if (selectedRightArrow) drawPicture(121, 22, 6, 20, right_arrow_bitmap);
  else drawPicture(121, 22, 6, 20, right_arrow_empty_bitmap);
  drawPicture(120, 56, 6, 6, back_arrow_bitmap);

  u8g2.drawFrame(cursorX, cursorY, cursorW, cursorH);

  if (!terrsList[getCurrentTerrIndex()].light.isHeatOff) {
    isInverted = true;
    drawPicture(12, 13, 48, 48, heat_bitmap);
    isInverted = false;
  }
  if (!terrsList[getCurrentTerrIndex()].light.isLightOff) {
    isInverted = true;
    drawPicture(68, 13, 48, 48, light_big_bitmap);
    isInverted = false;
  }
}

void onClickLH(int n) {  // Checks if the middle button is pressed to return to the main menu

  switch (n) {
    case 1:
      if (selectedItem == 1) selectedItem = 5;
      else selectedItem -= 1;
      break;
    case 2:
      switch (selectedItem) {
        case 1:
          selectedWindow = 1;   // Return to Main Menu
          break;
        case 2:
          switchTerr(true);
          break;
        case 3: // Manually diable the Heat Lamp
          if (terrsList[getCurrentTerrIndex()].light.isHeatOff) terrsList[getCurrentTerrIndex()].light.isHeatOff = false;
          else terrsList[getCurrentTerrIndex()].light.isHeatOff = true;
          break;
        case 4: // Manually disable the LED lamp
          if (terrsList[getCurrentTerrIndex()].light.isLightOff) terrsList[getCurrentTerrIndex()].light.isLightOff = false;
          else terrsList[getCurrentTerrIndex()].light.isLightOff = true;
          break;
        case 5:
          switchTerr(false);
          break;
        default:
          break;  //ERROR WEIRD SHIT! do later.0
      }
      break;
    case 3:
      if (selectedItem == 5) selectedItem = 1;
      else selectedItem += 1;
      break;
    default:
      break;  //ERROR WEIRD SHIT! do later.
  }
}

//--------------------------------------------------------Sunrise&Sunset---------------------------------------------------------//

void calculateSunrise() {
  sprintf(terrNumStr, "%d", terrNumSelected);   // Prepares the data to write

  if (selectedItem != 2 && selectedItem != 7) {
    selectedLeftArrow = false;
    selectedRightArrow = false;
  }

  switch (selectedItem) {   // Sets cursor position
    case 1:
      selectReturn();
      break;
    case 2:
      selectArrow(true);
      break;
    case 3:
      cursorX = 8 + 11 + sunriseShifts[0];
      cursorY = 11 + 16 + sunriseShifts[4];
      cursorH = 11;
      cursorW = 33;
      break;
    case 4:
      cursorX = 8 + 11 + sunriseShifts[1];
      cursorY = 11 + 16 + sunriseShifts[5];
      cursorH = 11;
      cursorW = 33;
      break;
    case 5:
      cursorX = 8 + 11 + sunriseShifts[2];
      cursorY = 11 + 16 + sunriseShifts[6];
      cursorH = 11;
      cursorW = 33;
      break;
    case 6:
      cursorX = 8 + 11 + sunriseShifts[3];
      cursorY = 11 + 16 + sunriseShifts[7];
      cursorH = 11;
      cursorW = 33;
      break;
    case 7:
      selectArrow(false);
      break;
    default:
      break;  //ERROR WEIRD SHIT! do later.
  }
}

void openSunrise() {
  drawBorder();
  drawHeader("Sunrise & Sunset");

  u8g2.drawLine(7, 10, 7, scrH - 10);
  u8g2.drawLine(scrW - 8, 10, scrW - 8, scrH - 10);

  u8g2.drawFrame(118, 54, 10, 10);  // Places an immovable (while only 1 terrarium in stack) cursor that can only lead back to the main menu
  u8g2.drawFrame(0, 54, 10, 10);

  u8g2.drawLine(64, 10, 64, scrH - 1);

  u8g2.drawStr(10, 19, "Sunrise");
  u8g2.drawStr(66, 19, "Sunset");
  u8g2.drawLine(7, 20, scrW - 8, 20);

  u8g2.drawStr(3, scrH - 1, terrNumStr);

  if (selectedLeftArrow) drawPicture(1, 22, 6, 20, left_arrow_bitmap);
  else drawPicture(1, 22, 6, 20, left_arrow_empty_bitmap);
  if (selectedRightArrow) drawPicture(121, 22, 6, 20, right_arrow_bitmap);
  else drawPicture(121, 22, 6, 20, right_arrow_empty_bitmap);
  drawPicture(120, 56, 6, 6, back_arrow_bitmap);

  if (selectedWindow == 6) u8g2.drawFrame(cursorX, cursorY, cursorW, cursorH);
  else {
    if (isHours) u8g2.drawBox(cursorX, cursorY, cursorW - 18, cursorH);
    else u8g2.drawBox(cursorX + 18, cursorY, cursorW - 18, cursorH);
  }

  drawTimeSS(terrsList[getCurrentTerrIndex()]);
}

void onClickSS(int n) {
  switch (n) {
    case 1:
      if (selectedItem == 1) selectedItem = 7;
      else selectedItem -= 1;
      break;
    case 2:
      switch (selectedItem) {
        case 1:
          selectedWindow = 5;   // Return to Daylight Cycle
          break;
        case 2:
          switchTerr(true);
          break;
        case 3:
          selectedWindow = 9;   // Set time for selected item
          prevWindow = 6;
          break;
        case 4:
          selectedWindow = 9;   // Set time for selected item
          prevWindow = 6;
          break;
        case 5:
          selectedWindow = 9;   // Set time for selected item
          prevWindow = 6;
          break;
        case 6:
          selectedWindow = 9;   // Set time for selected item
          prevWindow = 6;
          break;
        case 7:
          switchTerr(false);
          break;
        default:
          break;  //ERROR WEIRD SHIT! do later.0
      }
      break;
    case 3:
      if (selectedItem == 7) selectedItem = 1;
      else selectedItem += 1;
      break;
    default:
      break;  //ERROR WEIRD SHIT! do later.
  }
}

void drawTimeSS(Terr terr) {  // Basically same as drawTimeMM()
  for (int i = 0; i < 4; i++) {

    if (selectedWindow == 9 && selectedItem == i + 3 && isHours) u8g2.setColorIndex(0);

    sprintf(sunriseStr, "%02d", terr.sunriseHours[i]);
    u8g2.drawStr(8 + 13 + sunriseShifts[i], 20 + 16 + sunriseShifts[i + 4], sunriseStr);

    u8g2.setColorIndex(1);

    drawPicture(8 + 13 + 12 + 2 + sunriseShifts[i], 20 + 16 - 6 + sunriseShifts[i + 4], 1, 5, colon_bitmap);

    if (selectedWindow == 9 && selectedItem == i + 3 && !isHours) u8g2.setColorIndex(0);

    sprintf(sunriseStr, "%02d", terr.sunriseMinutes[i]);
    u8g2.drawStr(8 + 13 + 18 + sunriseShifts[i], 20 + 16 + sunriseShifts[i + 4], sunriseStr);

    u8g2.setColorIndex(1);
  }
}

//---------------------------------------------------------Daylight-Cycle--------------------------------------------------------//

void calculateDaylight() {
  sprintf(terrNumStr, "%d", terrNumSelected);   // Prepares the data to write

  if (selectedItem != 2 && selectedItem != 9) {
    selectedLeftArrow = false;
    selectedRightArrow = false;
  }

  switch (selectedItem) {   // Sets cursor position
    case 1:
      selectReturn();
      break;
    case 2:
      selectArrow(true);
      break;
    case 3:
      cursorX = 8 + 2 + daylightShifts[0];
      cursorY = 11 + 16 + daylightShifts[4];
      cursorH = 11;
      cursorW = 33;
      break;
    case 4:
      cursorX = 8 + 2 + daylightShifts[1];
      cursorY = 11 + 16 + daylightShifts[5];
      cursorH = 11;
      cursorW = 33;
      break;
    case 5:
      cursorX = 8 + 2 + daylightShifts[2];
      cursorY = 11 + 16 + daylightShifts[6];
      cursorH = 11;
      cursorW = 33;
      break;
    case 6:
      cursorX = 8 + 2 + daylightShifts[3];
      cursorY = 11 + 16 + daylightShifts[7];
      cursorH = 11;
      cursorW = 33;
      break;
    case 7:
      cursorX = scrW - 8 - 26;
      cursorY = 10 + 1;
      cursorH = 25;
      cursorW = 25;
      break;
    case 8:
      cursorX = scrW - 8 - 26;
      cursorY = 36 + 2;
      cursorH = 25;
      cursorW = 25;
      break;
    case 9:
      selectArrow(false);
      break;
    default:
      break;  //ERROR WEIRD SHIT! do later.
  }
}

void openDaylight() {
  drawBorder();
  drawHeader("Daylight Cycle");

  u8g2.drawLine(7, 10, 7, scrH - 10);
  u8g2.drawLine(scrW - 8, 10, scrW - 8, scrH - 10);

  u8g2.drawFrame(118, 54, 10, 10);  // Places an immovable (while only 1 terrarium in stack) cursor that can only lead back to the main menu
  u8g2.drawFrame(0, 54, 10, 10);

  u8g2.drawLine(49, 10, 49, scrH - 1);
  u8g2.drawLine(scrW - 8 - 28, 10, scrW - 8 - 28, scrH - 1);
  u8g2.drawLine(scrW - 8 - 28, 36, scrW - 8, 36);
  u8g2.drawLine(scrW - 8 - 28, 37, scrW - 8, 37);

  u8g2.drawStr(10, 19, "Heat");
  u8g2.drawStr(51, 19, "Light");
  u8g2.drawLine(7, 20, scrW - 8 - 28, 20);

  u8g2.drawStr(3, scrH - 1, terrNumStr);

  drawPicture(scrW - 9 - 24, 11, 23, 23, sunrise_bitmap);

  if (terrsList[getCurrentTerrIndex()].winterIsActive) {    // Inverts the Winter bitmap if Winter Prep mode is active
    isInverted = true;
    drawPicture(scrW - 9 - 24, 39, 23, 23, winter_bitmap);
    isInverted = false;
  } else drawPicture(scrW - 9 - 24, 39, 23, 23, winter_bitmap);

  if (selectedLeftArrow) drawPicture(1, 22, 6, 20, left_arrow_bitmap);
  else drawPicture(1, 22, 6, 20, left_arrow_empty_bitmap);
  if (selectedRightArrow) drawPicture(121, 22, 6, 20, right_arrow_bitmap);
  else drawPicture(121, 22, 6, 20, right_arrow_empty_bitmap);
  drawPicture(120, 56, 6, 6, back_arrow_bitmap);

  if (selectedWindow == 5) u8g2.drawFrame(cursorX, cursorY, cursorW, cursorH);
  else {
    if (isHours) u8g2.drawBox(cursorX, cursorY, cursorW - 18, cursorH);
    else u8g2.drawBox(cursorX + 18, cursorY, cursorW - 18, cursorH);
  }

  drawTimeDC(terrsList[getCurrentTerrIndex()]);
}

void onClickDC(int n) {
  switch (n) {
    case 1:
      if (selectedItem == 1) selectedItem = 9;
      else selectedItem -= 1;
      break;
    case 2:
      switch (selectedItem) {
        case 1:
          selectedWindow = 1;
          break;
        case 2:
          switchTerr(true);
          break;
        case 3:
          selectedWindow = 9;   // Set time for selected item
          prevWindow = 5;
          break;
        case 4:
          selectedWindow = 9;   // Set time for selected item
          prevWindow = 5;
          break;
        case 5:
          selectedWindow = 9;   // Set time for selected item
          prevWindow = 5;
          break;
        case 6:
          selectedWindow = 9;   // Set time for selected item
          prevWindow = 5;
          break;
        case 7:
          selectedWindow = 6;   // Open Sunrise & Sunset
          selectedItem = 1;
          break;
        case 8:
          selectedWindow = 7;   // Open Winter Prep
          selectedItem = 1;
          break;
        case 9:
          switchTerr(false);
          break;
        default:
          break;  //ERROR WEIRD SHIT! do later.0
      }
      break;
    case 3:
      if (selectedItem == 9) selectedItem = 1;
      else selectedItem += 1;
      break;
    default:
      break;  //ERROR WEIRD SHIT! do later.
  }
}

void drawTimeDC(Terr terr) {    // Basically same as drawTimeMM()
  for (int i = 0; i < 4; i++) {

    if (selectedWindow == 9 && selectedItem == i + 3 && isHours) u8g2.setColorIndex(0);

    sprintf(sunriseStr, "%02d", terr.daylightHours[i]);
    u8g2.drawStr(8 + 4 + daylightShifts[i], 20 + 16 + daylightShifts[i + 4], sunriseStr);

    u8g2.setColorIndex(1);

    drawPicture(8 + 4 + 12 + 2 + daylightShifts[i], 20 + 16 - 6 + daylightShifts[i + 4], 1, 5, colon_bitmap);

    if (selectedWindow == 9 && selectedItem == i + 3 && !isHours) u8g2.setColorIndex(0);

    sprintf(sunriseStr, "%02d", terr.daylightMinutes[i]);
    u8g2.drawStr(8 + 4 + 18 + daylightShifts[i], 20 + 16 + daylightShifts[i + 4], sunriseStr);

    u8g2.setColorIndex(1);
  }
}

//----------------------------------------------------------Winter-Prep----------------------------------------------------------//

void calculateWinter() {
  sprintf(terrNumStr, "%d", terrNumSelected);   // Prepares the data to write

  if (selectedItem != 2 && selectedItem != 8) {
    selectedLeftArrow = false;
    selectedRightArrow = false;
  }

  switch (selectedItem) {   // Sets cursor position
    case 1:
      selectReturn();
      break;
    case 2:
      selectArrow(true);
      break;
    case 3:
      cursorX = 7 + 1;
      cursorY = 10 + 1;
      cursorH = 8;
      cursorW = 8;
      break;
    case 4:
      cursorX = 8 + 11;
      cursorY = 20 + 2;
      cursorH = 11;
      cursorW = 15;
      break;
    case 5:
      cursorX = 8 + 11;
      cursorY = 20 + 2 + 14 + 14;
      cursorH = 11;
      cursorW = 33;
      break;
    case 6:
      cursorX = 64 + 14;
      cursorY = 20 + 2 + 14 + 14;
      cursorH = 11;
      cursorW = 27;
      break;
    case 7:
      cursorX = scrW - 17 + 1;
      cursorY = 10 + 1;
      cursorH = 8;
      cursorW = 8;
      break;
    case 8:
      selectArrow(false);
      break;
    default:
      break;  //ERROR WEIRD SHIT! do later.
  }
}

void openWinter() {
  drawBorder();
  drawHeader("Winter Prep");

  u8g2.drawLine(7, 10, 7, scrH - 10);
  u8g2.drawLine(scrW - 8, 10, scrW - 8, scrH - 10);

  u8g2.drawFrame(118, 54, 10, 10);  // Places an immovable (while only 1 terrarium in stack) cursor that can only lead back to the main menu
  u8g2.drawFrame(0, 54, 10, 10);
  u8g2.drawFrame(7, 10, 10, 10);
  u8g2.drawFrame(111, 10, 10, 10);

  drawPicture(9, 12, 6, 6, back_arrow_bitmap_og);
  drawPicture(113, 12, 6, 6, front_arrow_bitmap);

  u8g2.drawLine(64, 10, 64, scrH - 1);

  u8g2.drawStr(20, 19, "Day");
  sprintf(dayNumStr, "%02d", terrsList[getCurrentTerrIndex()].dayNumSelected);
  u8g2.drawStr(20 + 24, 19, dayNumStr);
  u8g2.drawStr(66, 19, "Status");
  u8g2.drawLine(17, 20, scrW - 18, 20);

  if (selectedLeftArrow) drawPicture(1, 22, 6, 20, left_arrow_bitmap);
  else drawPicture(1, 22, 6, 20, left_arrow_empty_bitmap);
  if (selectedRightArrow) drawPicture(121, 22, 6, 20, right_arrow_bitmap);
  else drawPicture(121, 22, 6, 20, right_arrow_empty_bitmap);
  drawPicture(120, 56, 6, 6, back_arrow_bitmap);

  sprintf(winterDayVal, "%02d", terrsList[getCurrentTerrIndex()].winterDays[terrsList[getCurrentTerrIndex()].dayNumSelected - 1]);
  u8g2.drawStr(8 + 13, 29 + 2, winterDayVal);
  u8g2.setColorIndex(1);
  u8g2.drawStr(8 + 13 + 18, 29 + 2, "h");

  sprintf(winterDayVal, "%02d", 24 - terrsList[getCurrentTerrIndex()].winterDays[terrsList[getCurrentTerrIndex()].dayNumSelected - 1]);
  u8g2.drawStr(8 + 13, 29 + 2 + 14, winterDayVal);
  u8g2.drawStr(8 + 13 + 18, 29 + 2 + 14, "h");
  u8g2.drawStr(8 + 13, 29 + 2 + 14 + 14, "Start");

  u8g2.drawStr(64 + 16, 29 + 2 + 14 + 14, "Stop");

  if (selectedWindow == 7) u8g2.drawFrame(cursorX, cursorY, cursorW, cursorH);
  else {
    u8g2.drawBox(cursorX, cursorY, cursorW, cursorH);
    u8g2.setColorIndex(0);
  }

  if (terrsList[getCurrentTerrIndex()].winterIsActive) u8g2.drawStr(64 + 5, 29 + 2 + 7, "Active");
  else u8g2.drawStr(64 + 5, 29 + 2 + 7, "Inactive");

  u8g2.drawStr(3, scrH - 1, terrNumStr);
}

void onClickWP(int n) {
  switch (n) {
    case 1:
      if (selectedItem == 1) selectedItem = 8;
      else selectedItem -= 1;
      break;
    case 2:
      switch (selectedItem) {
        case 1:
          selectedWindow = 5;   // Returns to Daylight Cycle
          break;
        case 2:
          switchTerr(true);
          break;
        case 3:   // Proceeds to previous wintere prep day
          if (terrsList[getCurrentTerrIndex()].dayNumSelected > 1) terrsList[getCurrentTerrIndex()].dayNumSelected--;
          break;
        case 4:
          selectedWindow = 10;
          prevWindow = 7;
          break;
        case 5:
          terrsList[getCurrentTerrIndex()].winterIsActive = true;
          break;
        case 6:
          terrsList[getCurrentTerrIndex()].winterIsActive = false;
          break;
        case 7:   // Proceeds to next wintere prep day
          if (terrsList[getCurrentTerrIndex()].dayNumSelected < 20) terrsList[getCurrentTerrIndex()].dayNumSelected++;
          break;
        case 8:
          switchTerr(false);
          break;
        default:
          break;  //ERROR WEIRD SHIT! do later.0
      }
      break;
    case 3:
      if (selectedItem == 8) selectedItem = 1;
      else selectedItem += 1;
      break;
    default:
      break;  //ERROR WEIRD SHIT! do later.
  }
}

//-----------------------------------------------------------Err-Menu------------------------------------------------------------//

void calculateErrMenu() {
  if (selectedItem == 1) selectReturn();    // Sets cursor position
  else {
    if (1 < selectedItem && selectedItem < getLastErrIndex() + 3) {
      cursorX = 8;
      cursorY = 11 + 11;
      cursorW = 112;
      cursorH = 29;
    } else {
    }  //ERROR: Weird shit. Do later.
  }
}

void openErrMenu() {
  drawBorder();
  drawHeader("Error Log");

  u8g2.drawFrame(118, 54, 10, 10);
  drawPicture(120, 56, 6, 6, back_arrow_bitmap_og);

  if (getLastErrIndex() == -1) u8g2.drawStr(10, 11 + 10 + 15, "No errors present.");  // Kind of obvious
  else {
    u8g2.drawFrame(9, 11 + 12, 110, 27);
    drawPicture(11, 11 + 14, 23, 23, error_bitmap_og);
    if (selectedItem == 1) {
      u8g2.drawStr(11 + 25, 11 + 11 + 10 + 1, errMessages[0]);
      drawDate(11 + 25, 11 + 11 + 10 + 1 + 10 + 2, errDates[0]);
    } else {
      u8g2.drawStr(11 + 25, 11 + 11 + 10 + 1, errMessages[selectedItem - 2]);
      drawDate(11 + 25, 11 + 11 + 10 + 1 + 10 + 2, errDates[selectedItem - 2]);
    }
  }

  if (selectedItem > 2) u8g2.drawFrame(9, 10, 110, 8);    // Draws a rectangle above the error to simulate scrolling
  if (selectedItem < getLastErrIndex() + 2) u8g2.drawFrame(9, scrH - 9, 110, 9);
  // Draws a rectangle below the error to simulate scrolling

  u8g2.drawFrame(cursorX, cursorY, cursorW, cursorH);
}

void onClickEM(int n) {
  switch (n) {
    case 1:
      if (getLastErrIndex() != -1) {
        if (selectedItem == 1) selectedItem = getLastErrIndex() + 2;
        else selectedItem--;
      }
      break;
    case 2:
      if (selectedItem == 1) selectedWindow = 1;    // Return to Main Menu
      else {
        if (1 < selectedItem && selectedItem < getLastErrIndex() + 3) {   // Open Error Fix
          selectedWindow = 8;
          currentErrIndex = selectedItem;   // To figure out which error you are fixing
          selectedItem = 1;
        } else {
        }  //ERROR: Weird shit. Do later.
      }
      break;
    case 3:
      if (getLastErrIndex() != -1) {
        if (selectedItem == getLastErrIndex() + 2) selectedItem = 1;
        else selectedItem++;
      }
      break;
    default:
      break;
  }
}

//-----------------------------------------------------------Error-Fix-----------------------------------------------------------//

void calculateErrFix() {
  switch (selectedItem) {   // Sets cursor position
    case 1:
      cursorX = 39 + 1 + 2 + 18 + 1 + 6;
      cursorY = 11 + 5 + 6 + 9 + 6;
      cursorW = 21;
      cursorH = 11;
      break;
    case 2:
      cursorX = 39 + 1;
      cursorY = 11 + 5 + 6 + 9 + 6;
      cursorW = 21;
      cursorH = 11;
      break;
    default:
      break;
  }
}

void openErrFix() {

  u8g2.setColorIndex(0);
  u8g2.drawBox(33, 11 + 5, 56 + 6, 42);
  u8g2.setColorIndex(1);
  u8g2.drawFrame(33, 11 + 5, 56 + 6, 42);

  u8g2.drawStr(39 + 5, 11 + 5 + 6 + 9, "Fixed?");
  u8g2.drawStr(39 + 1 + 2, 11 + 5 + 6 + 9 + 6 + 9, "Yes");
  u8g2.drawStr(39 + 1 + 2 + 18 + 1 + 6 + 2 + 3, 11 + 5 + 6 + 9 + 6 + 9, "No");

  u8g2.drawFrame(cursorX, cursorY, cursorW, cursorH);
}

void onClickEF(int n) {
  short int lastIndex = getLastErrIndex();

  switch (n) {
    case 1:
      if (selectedItem == 1) selectedItem = 2;
      else selectedItem = 1;
      break;
    case 2:
      if (selectedItem == 1) {    // "No" - Returns to Error Menu
        selectedWindow = 4;
        selectedItem = currentErrIndex;
      } else {
        errCodes[errCodePositions[currentErrIndex - 2]] = 0;    // "Yes" - clears the error
        for (int i = currentErrIndex - 2; i <= lastIndex; i++) {    
          // Shifts the error arrays one to the left to remove the "hole"
          if (i < lastIndex) {
            for (int j = 0; j < 21; j++) errMessages[i][j] = errMessages[i + 1][j];
            for (int j = 0; j < 3; j++) errDates[i][j] = errDates[i + 1][j];
            errCodePositions[i] = errCodePositions[i + 1];
          } else {
            errMessages[i][1] = '\0';
            for (int j = 0; j < 3; j++) errDates[i][j] = 0;
          }

          /*
          // Debugging
          Serial.println("DELETING");
          Serial.printf("RTC = %d, THS1 = %d, THS2 = %d, THS3 = %d, THS4 = %d, THS5 = %d, THS6 = %d, T1LF = %d, T2LF = %d, T3LF = %d, 10 = %d, 11 = %d, 12 = %d", errCodes[0], errCodes[1], errCodes[2], errCodes[3], errCodes[4], errCodes[5], errCodes[6], errCodes[7], errCodes[8], errCodes[9], errCodes[10], errCodes[11]);
          Serial.println("");

          for (int i = 0; i <= lastIndex; i++) {
            Serial.print(errCodePositions[i]);
            Serial.print(",   ");
            Serial.print(errMessages[i]);
            Serial.print(",   ");
            Serial.print(errDates[i][0]);
            Serial.print(",");
            Serial.print(errDates[i][1]);
            Serial.print(",");
            Serial.println(errDates[i][2]);
          }
          */
        }
        selectedWindow = 4;
        selectedItem = currentErrIndex - 1;
      }
      break;
    case 3:
      if (selectedItem == 2) selectedItem = 1;
      else selectedItem = 2;
      break;
  }
}

//-----------------------------------------------------------Main-Body-----------------------------------------------------------//

void setup()
{
  Serial.begin(9600);
  Wire.begin(SDA_PIN, SCL_PIN);   // Init I2C

  X9C.reset();    // Init Test Dimmer

  initTerrs();

  for (int i = 0; i < 3; i++)   // Calculate amount of terrs
    if (terrNums[i] != 0) terrCount++;

  /*
  for (int i = 0; i < 3; i++) {
    sprintf(errMessages[i], "%d_123456789AB", i);
    errDates[i][0] = mainDay + i;
    errDates[i][1] = mainMonth;
    errDates[i][2] = mainYear;
  }
  */

  for (int i = 0; i < 64; i++) {    // Prepare errMeaasges array
    errMessages[i][0] = 0;
    errMessages[i][1] = '\0';
  }

  delay(1000);

  if (!rtc.begin()) {   // Innit RTC
    Serial.println("Real Time Clock Not Found!");
    Serial.flush();
    //while(1) delay(10);
  }

  //rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));

  if (rtc.lostPower()) {
    Serial.print("Real Time Clock Lost Power");
    rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
  }

  //pinMode(bL, INPUT);
  //pinMode(bC, INPUT);
  pinMode(encoderButton, INPUT_PULLUP);   //
                                          //
  pinMode(e, OUTPUT);                     //
  pinMode(rs, OUTPUT);                    //
  pinMode(rw, OUTPUT);                    // pinModes
  pinMode(rst, OUTPUT);                   //
                                          //
  pinMode(encoderPinA, INPUT_PULLUP);     //
  pinMode(encoderPinB, INPUT_PULLUP);     //

  attachInterrupt(digitalPinToInterrupt(encoderPinA), isrA, CHANGE);                    //
  attachInterrupt(digitalPinToInterrupt(encoderPinB), isrB, CHANGE);                    // Interrupts guarantee encoder response
  attachInterrupt(digitalPinToInterrupt(encoderButton), encoderButton_ISR, RISING);     //

  u8g2.setFont(u8g_font_6x10);  // Выбор шрифта

  u8g2.setColorIndex(1);

  calculateMainMenu();
}



void loop() {

  if (digitalRead(encoderButton) == LOW) {
    while (digitalRead(encoderButton) == LOW)
    onClickInterrupt(2);
  }

  noInterrupts();
  protectedCount = count;
  interrupts();

  if (protectedCount != previousCount) {
    Serial.println(protectedCount);
  }
  previousCount = protectedCount;

  //getTime();

  setTimeTemp();

  changeDimmer();

  if (getLastErrIndex() != -1) errFlash(false);
  else errFlash(true);

  toggleHeat();
  toggleLight();

  if (millis() - currTime >= 500) {
    getTempAndHum();  // Get the latest sensor data
    getCurrent();
  }

  switch (selectedWindow) {  // Draws the selected window
    case 1:
      calculateMainMenu();
      break;
    case 2:
      calculateTempHumid();
      break;
    case 3:
      calculateLightHeat();
      break;
    case 4:
      calculateErrMenu();
      break;
    case 5:
      calculateDaylight();
      break;
    case 6:
      calculateSunrise();
      break;
    case 7:
      calculateWinter();
      break;
    case 8:
      calculateErrFix();
      break;
    case 9:
      switch (prevWindow) {
        case 1:
          calculateMainMenu();
          break;
        case 5:
          calculateDaylight();
          break;
        case 6:
          calculateSunrise();
          break;
      }
      break;
    case 10:
      calculateWinter();
      break;
    default:
      //ERROR WEIRD SHIT! do later.
      break;
  }

  u8g2.firstPage();  // Starts the drawing loop


  do {                         // The drawing loop
    switch (selectedWindow) {  // Draws the selected window
      case 1:
        openMainMenu();
        break;
      case 2:
        openTempHumid();
        break;
      case 3:
        openLightHeat();
        break;
      case 4:
        openErrMenu();
        break;
      case 5:
        openDaylight();
        break;
      case 6:
        openSunrise();
        break;
      case 7:
        openWinter();
        break;
      case 8:
        openErrMenu();
        openErrFix();
        break;
      case 9:
        switch (prevWindow) {
          case 1:
            openMainMenu();
            break;
          case 5:
            openDaylight();
            break;
          case 6:
            openSunrise();
            break;
        }
        break;
      case 10:
        openWinter();
        break;
      default:
        //ERROR WEIRD SHIT! do later.
        break;
    }
    //buttonPressed = checkButtons();
    //if (buttonPressed != 0) Serial.println(buttonPressed);

  } while (u8g2.nextPage());
}
