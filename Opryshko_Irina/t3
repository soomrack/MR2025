#include <DHT.h>

// Конфигурация пинов
#define DATA_SENSOR A5 
#define SOIL_MOISTURE_SENSOR A3 
#define DHT_AIR_HUMIDITY_SENSOR 12 
#define DHT_TYPE DHT11            
#define TEMPERATURE_SENSOR_2 A4 
#define LIGHT_SENSOR_1 A0 
#define LIGHT_SENSOR_2 A1 
#define LIGHT_SENSOR_3 A2 

#define BLOWER_PIN 7   
#define LIGHT_PIN 6 
#define HEATER_PIN 4   
#define WATERING_PIN 5  

DHT dht(DHT_AIR_HUMIDITY_SENSOR, DHT_TYPE);

// Константы интервалов
const unsigned long SENSOR_READ_INTERVAL = 10000;
const unsigned long SERIAL_PRINT_INTERVAL = 5000;
const unsigned long WATERING_DURATION = 2000;

// --- Пороги с гистерезисом
const int HEATER_ON_TEMP = 18;   
const int HEATER_OFF_TEMP = 22;  
const int BLOWER_ON_TEMP = 30;   
const int BLOWER_OFF_TEMP = 27;  
const int LIGHT_ON_LEVEL = 600;  
const int LIGHT_OFF_LEVEL = 550; 
const int HUMIDITY_ON_BLOWER = 95;  
const int HUMIDITY_OFF_BLOWER = 85; 

// Порог почвы
const int SOIL_DRY_TRIGGER = 1000; // Порог начала полива
const int SOIL_MOIST_LIMIT = 300;  // Критич влажность

// Глобальные переменные
int current_hours = 10; 
unsigned long last_time_update = 0;
unsigned long last_sensor_read_time = 0;
unsigned long last_serial_print_time = 0;
unsigned long watering_start_time = 0;
bool is_watering = false;

float soil_moisture;
float light_1, light_2, light_3;
float temperature_1, temperature_2, avg_temp;
float air_humidity;

// Чтение датчиков
void read_sensors() {
    soil_moisture = analogRead(SOIL_MOISTURE_SENSOR);
    light_1 = analogRead(LIGHT_SENSOR_1);
    light_2 = analogRead(LIGHT_SENSOR_2);
    light_3 = analogRead(LIGHT_SENSOR_3);
    air_humidity = dht.readHumidity();
    temperature_1 = dht.readTemperature();
    
    // Перевод напряжения в градусы (для LM35 или аналогов)
    temperature_2 = analogRead(TEMPERATURE_SENSOR_2) * 0.188; //перевод в цельсии
    
    if (isnan(temperature_1)) {
        avg_temp = temperature_2;
    } else {
        avg_temp = (temperature_1 + temperature_2) / 2;
    }
}

// Управление поливом
void control_watering(unsigned long current_time) {
    if (soil_moisture > SOIL_DRY_TRIGGER && !is_watering) {
        digitalWrite(WATERING_PIN, HIGH);
        watering_start_time = current_time;
        is_watering = true;
        Serial.println("Начат полив!");
    }

    if (is_watering && (current_time - watering_start_time >= WATERING_DURATION)) {
        digitalWrite(WATERING_PIN, LOW);
        is_watering = false;
        Serial.println("Полив завершен!");
    }
}

// Управление обогревом (гистерезис)
void control_blower() {
    bool need_blower = false;

    // Условия включения
    if (avg_temp >= BLOWER_ON_TEMP || air_humidity >= HUMIDITY_ON_BLOWER || soil_moisture <= SOIL_MOIST_LIMIT) {
        need_blower = true;
    }
    else if (current_hours == 12 || current_hours == 18) {
        need_blower = true;
    }

    // Условия выключения
    if (need_blower) {
        digitalWrite(BLOWER_PIN, HIGH);
    } 
    else if (avg_temp <= BLOWER_OFF_TEMP && air_humidity <= HUMIDITY_OFF_BLOWER) {
        digitalWrite(BLOWER_PIN, LOW);
    }
}

// Обогрев (гистерезис)
void control_heater() {
    if (avg_temp <= HEATER_ON_TEMP) {
        digitalWrite(HEATER_PIN, HIGH);
    } 
    else if (avg_temp >= HEATER_OFF_TEMP) {
        digitalWrite(HEATER_PIN, LOW);
    }
}

// Свет (гистерезис)
void control_light() {
    float max_light = max(light_1, max(light_2, light_3));
    
    if (max_light >= LIGHT_ON_LEVEL) {
        digitalWrite(LIGHT_PIN, HIGH);
    } 
    else if (max_light <= LIGHT_OFF_LEVEL) {
        digitalWrite(LIGHT_PIN, LOW);
    }
}

void night_mode() {
    digitalWrite(LIGHT_PIN, LOW);
    digitalWrite(HEATER_PIN, LOW);
    digitalWrite(BLOWER_PIN, LOW);
    digitalWrite(WATERING_PIN, LOW);
    is_watering = false;
}

void update_hours(unsigned long current_time) {
    if (current_time - last_time_update >= 3600000) {
        current_hours++;
        last_time_update = current_time;
    }
    if (current_hours >= 24) current_hours = 0;
}

void print_sensor_data() {
    Serial.println("--- ТЕПЛИЦА ---");
    Serial.print("Время: "); Serial.print(current_hours); Serial.println(":00");
    Serial.print("Почва: "); Serial.println(soil_moisture);
    Serial.print("Температура: "); Serial.println(avg_temp);
    Serial.print("Влажность воздуха: "); Serial.println(air_humidity);
    Serial.print("Датчик 1: "); Serial.println(light_1);
    Serial.print("Датчик 2: "); Serial.println(light_2);
    Serial.print("Датчик 3: "); Serial.println(light_3);
    
    // Вычисляем максимум (то, на что ориентируется код)
    float current_max_light = max(light_1, max(light_2, light_3));
    Serial.print("ТЕКУЩИЙ МАКСИМУМ: "); Serial.println(current_max_light);

    // Выводим границы (пороги)
    Serial.print("ПОРОГ ВКЛЮЧЕНИЯ (нужно больше): "); Serial.println(LIGHT_ON_LEVEL);
    Serial.print("ПОРОГ ВЫКЛЮЧЕНИЯ (нужно меньше): "); Serial.println(LIGHT_OFF_LEVEL);

    // Статус лампы текстом
    Serial.print("СТАТУС ЛАМПЫ: ");
    if (digitalRead(LIGHT_PIN) == HIGH) {
        Serial.println(">>> ВКЛЮЧЕНА <<<");
    } else {
        Serial.println("--- ВЫКЛЮЧЕНА ---");
    }
    Serial.println("---------------");
}

void setup() {
    Serial.begin(9600);
    dht.begin();

    pinMode(BLOWER_PIN, OUTPUT);
    pinMode(HEATER_PIN, OUTPUT);
    pinMode(LIGHT_PIN, OUTPUT);
    pinMode(WATERING_PIN, OUTPUT);

    // Мигание при старте
    for (int i = 0; i < 3; i++) {
        digitalWrite(LIGHT_PIN, HIGH);
        delay(300);
        digitalWrite(LIGHT_PIN, LOW);
        delay(300);
    }
    
    Serial.println("Система запущена!");
}

void loop() {
    unsigned long current_time = millis();

    update_hours(current_time);

    if (current_hours >= 21 || current_hours <= 7) {
        night_mode();
    } else {
        if (current_time - last_sensor_read_time >= SENSOR_READ_INTERVAL) {
            last_sensor_read_time = current_time;
            read_sensors();
            control_heater();
            control_light();
            control_watering(current_time);
            control_blower();
        }
    }

    if (current_time - last_serial_print_time >= SERIAL_PRINT_INTERVAL) {
        print_sensor_data();
        last_serial_print_time = current_time;
    }
}
